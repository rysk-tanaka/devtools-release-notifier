#!/usr/bin/env python3
"""Extract Claude's response from claude-code-action execution file.

This script parses the execution file generated by anthropics/claude-code-action
and extracts the final Claude response containing the translated release information.
"""

import json
import re
import sys
from pathlib import Path

from pydantic import ValidationError

from devtools_release_notifier.models.output import TranslatedRelease


def extract_json_from_text(text: str) -> str | None:
    """Extract JSON array from text.

    Args:
        text: Text containing JSON

    Returns:
        Extracted JSON string or None if not found
    """
    # First, try to extract from markdown code blocks
    markdown_pattern = r"```(?:json)?\s*(\[.+?\])\s*```"
    markdown_matches = re.findall(markdown_pattern, text, re.DOTALL)

    for match in reversed(markdown_matches):
        try:
            # Validate that it's actually valid JSON
            data = json.loads(match)
            # Validate structure with Pydantic
            if isinstance(data, list):
                [TranslatedRelease(**item) for item in data]
            return match
        except (json.JSONDecodeError, ValidationError):
            # Invalid JSON or structure, try next match
            continue

    # If no markdown code blocks, try to find raw JSON array
    json_pattern = r"\[\s*\{.*?\}\s*\]"
    matches = re.findall(json_pattern, text, re.DOTALL)

    # Try matches from last to first (most recent response first)
    for match in reversed(matches):
        try:
            # Validate that it's actually valid JSON
            data = json.loads(match)
            # Validate structure with Pydantic
            if isinstance(data, list):
                [TranslatedRelease(**item) for item in data]
            return match
        except (json.JSONDecodeError, ValidationError):
            # Invalid JSON or structure, try next match
            continue

    return None


def _extract_from_result_item(item: dict) -> str | None:
    """Extract JSON from type='result' item.

    Args:
        item: Dictionary item from execution file

    Returns:
        Extracted JSON string or None if not found
    """
    if item.get("type") == "result" and "result" in item:
        response_text = item["result"]
        if isinstance(response_text, str):
            return extract_json_from_text(response_text)
    return None


def _extract_from_assistant_item(item: dict) -> str | None:
    """Extract JSON from type='assistant' item.

    Args:
        item: Dictionary item from execution file

    Returns:
        Extracted JSON string or None if not found
    """
    if item.get("type") != "assistant" or "message" not in item:
        return None

    message = item["message"]
    if not isinstance(message, dict) or "content" not in message:
        return None

    content = message["content"]

    # Content can be a list of content blocks
    if isinstance(content, list):
        for content_block in content:
            if isinstance(content_block, dict) and "text" in content_block:
                text = content_block["text"]
                if isinstance(text, str):
                    json_response = extract_json_from_text(text)
                    if json_response:
                        return json_response

    # Content can be a string
    elif isinstance(content, str):
        return extract_json_from_text(content)

    return None


def _extract_from_array_format(data: list) -> str | None:
    """Extract JSON from array format execution file.

    Args:
        data: List of execution file items

    Returns:
        Extracted JSON string or None if not found
    """
    for item in reversed(data):
        if not isinstance(item, dict):
            continue

        # Try result format
        json_response = _extract_from_result_item(item)
        if json_response:
            return json_response

        # Try assistant format
        json_response = _extract_from_assistant_item(item)
        if json_response:
            return json_response

    return None


def _extract_from_direct_fields(data: dict) -> str | None:
    """Extract JSON from direct fields like 'response', 'output', etc.

    Args:
        data: Dictionary execution file data

    Returns:
        Extracted JSON string or None if not found
    """
    for key in ["response", "output", "result", "content"]:
        if key in data:
            response_text = data[key]
            if isinstance(response_text, str):
                json_response = extract_json_from_text(response_text)
                if json_response:
                    return json_response
    return None


def _extract_from_messages_array(data: dict) -> str | None:
    """Extract JSON from messages array.

    Args:
        data: Dictionary execution file data

    Returns:
        Extracted JSON string or None if not found
    """
    if "messages" not in data or not isinstance(data["messages"], list):
        return None

    for msg in reversed(data["messages"]):
        if isinstance(msg, dict) and msg.get("role") == "assistant":
            content = msg.get("content", "")
            if isinstance(content, str):
                json_response = extract_json_from_text(content)
                if json_response:
                    return json_response

    return None


def _extract_from_conversation(data: dict) -> str | None:
    """Extract JSON from conversation/history/transcript.

    Args:
        data: Dictionary execution file data

    Returns:
        Extracted JSON string or None if not found
    """
    for key in ["conversation", "history", "transcript"]:
        if key not in data or not isinstance(data[key], list):
            continue

        if not data[key]:
            continue

        last_item = data[key][-1]
        if not isinstance(last_item, dict):
            continue

        for field in ["content", "text", "message"]:
            if field in last_item:
                text = last_item[field]
                if isinstance(text, str):
                    json_response = extract_json_from_text(text)
                    if json_response:
                        return json_response

    return None


def _extract_from_dict_format(data: dict) -> str | None:
    """Extract JSON from dict format execution file.

    Args:
        data: Dictionary execution file data

    Returns:
        Extracted JSON string or None if not found
    """
    # Try direct fields
    json_response = _extract_from_direct_fields(data)
    if json_response:
        return json_response

    # Try messages array
    json_response = _extract_from_messages_array(data)
    if json_response:
        return json_response

    # Try conversation/history
    json_response = _extract_from_conversation(data)
    if json_response:
        return json_response

    return None


def extract_claude_response(execution_file_path: str) -> str:
    """Extract Claude's final response from execution file.

    Args:
        execution_file_path: Path to execution file

    Returns:
        Extracted JSON string

    Raises:
        ValueError: If execution file cannot be parsed or response not found
    """
    file_path = Path(execution_file_path)

    if not file_path.exists():
        raise ValueError(f"Execution file not found: {execution_file_path}")

    try:
        with open(file_path) as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        raise ValueError(f"Failed to parse execution file as JSON: {e}") from e

    # Try array format
    if isinstance(data, list):
        json_response = _extract_from_array_format(data)
        if json_response:
            return json_response

    # Try dict format
    if isinstance(data, dict):
        json_response = _extract_from_dict_format(data)
        if json_response:
            return json_response

    # Fallback: search entire file content
    file_content = file_path.read_text()
    json_response = extract_json_from_text(file_content)
    if json_response:
        return json_response

    raise ValueError("Could not find translated JSON in execution file")


def main():
    """Main entry point."""
    if len(sys.argv) != 2:
        print("Usage: extract_claude_response.py <execution_file>", file=sys.stderr)
        sys.exit(1)

    execution_file = sys.argv[1]

    try:
        response = extract_claude_response(execution_file)
        print(response)
    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
